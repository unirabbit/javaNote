# 链表

## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

题解:

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode listNode = new ListNode(1);
        ListNode node = listNode;
        int flag=0, num =0;
        while(l1 != null || l2 != null){
            if(l1 == null){
                num = l2.val + flag;
                l2 = l2.next;
            }else if(l2 == null){
                num = l1.val + flag;
                l1 = l1.next;
                
            }else{
                num = l1.val + l2.val + flag;
                l1 = l1.next;
                l2 = l2.next;
            }
            flag = num/10;
            node.next =new ListNode(num%10);
            node = node.next;
        }
        if(flag != 0) node.next = new ListNode(flag);
        return listNode.next;
    }
```

## [(归并排序)148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

**示例 1：**

![img](https://gitee.com/adambang/pic/raw/master/sort_list_1.jpg)

> ```
> 输入：head = [4,2,1,3]
> 输出：[1,2,3,4]
> ```

**示例 2：**

![img](https://gitee.com/adambang/pic/raw/master/sort_list_2.jpg)

> ```
> 输入：head = [-1,5,3,4,0]
> 输出：[-1,0,3,4,5]
> ```

题解一（归并排序）：

归并排序，链表排序的最佳解决方案！

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return mergeSort(head);
    }

    // 归并排序
    private ListNode mergeSort(ListNode head){
        // 如果没有结点/只有一个结点，无需排序，直接返回
        if (head==null||head.next==null) return head;
        // 快慢指针找出中位点
        ListNode slowp=head,fastp=head.next.next,l,r;
        while (fastp!=null&&fastp.next!=null){
            slowp=slowp.next;
            fastp=fastp.next.next;
        }
        // 对右半部分进行归并排序
        r=mergeSort(slowp.next);
        // 链表判断结束的标志：末尾节点.next==null
        slowp.next=null;
        // 对左半部分进行归并排序
        l=mergeSort(head);
        return mergeList(l,r);
    }
    // 合并链表
    private ListNode mergeList(ListNode l,ListNode r){
        // 临时头节点
        ListNode root=new ListNode(-1);
        ListNode p=root;
        while (l!=null&&r!=null){
            if (l.val<r.val){
                p.next=l;
                l=l.next;
            }else {
                p.next=r;
                r=r.next;
            }
            p=p.next;
        }
        p.next=l==null?r:l;
        return root.next;
    }
}
```

