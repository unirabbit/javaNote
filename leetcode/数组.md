# 数组

## [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。
> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 

示例 2：

> 输入：nums = [2,2,2,2,2]
> 输出：1
> 解释：最长连续递增序列是 [2], 长度为1。

题解：

```java
public int findLengthOfLCIS(int[] nums) {
        if(nums.length == 0) return 0;
        int res=1,temp=1;
        for(int i =1; i< nums.length; i++){
            if(nums[i] > nums[i-1]) temp++;
            else temp =1;
            res= Math.max(res, temp);
        }
        return res;
    }
```



## [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

题解：

```java
public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int maxV = 1;
        dp[0] = 1;
        for(int i =1; i<nums.length; i++){
            dp[i] = 1;
            for(int j =0; j<i; j++){
               if(nums[i] > nums[j]){
                   dp[i] = Math.max(dp[i], dp[j] +1);
                   }
            }
            maxV =Math.max(maxV, dp[i]);
        }
        return maxV;
    }
```

## [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 

示例 1:

输入: [10,2]
输出: "102"
示例 2:

输入: [3,30,34,5,9]
输出: "3033459"


提示:

0 < nums.length <= 100

题解：

```java
public String minNumber(int[] nums) {
        List<String> list = new LinkedList<>();
        for(int num: nums){
            list.add(String.valueOf(num));
        }
        list.sort((x,y)->(x+y).compareTo(y+x));
        return String.join("", list);

    }
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int [] res = {-1, -1};
        int leftIdx = searchBoudary(nums, target, true);

        // 确认左边界是否在范围内，以及是否是目标值
        if (leftIdx == nums.length || nums[leftIdx] != target) {
            return res;
        }
        res[0] = leftIdx;
        res[1] = searchBoudary(nums, target, false) -1 ;
        return res;
    }

    public int searchBoudary(int[] nums, int target, boolean flagLeft){
        int left =0, right = nums.length;
        while(left < right){
            int mid = (left + right)/2;
            //求左边界时，右边缩小
            if(nums[mid] > target || (flagLeft && nums[mid] == target)){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        return left;
    }
}
```

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例：

> ```
> 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
> 
> 满足要求的三元组集合为：
> [
>   [-1, 0, 1],
>   [-1, -1, 2]
> ]
> ```

题解：

排序+双指针

```java
public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new LinkedList<>();
        if(nums.length < 3) return res;
        for(int i =0; i<nums.length-2; i++){
            int l = i+1, r = nums.length-1, sum = -nums[i];
            //过滤第一个数重复的情况
            if(i>0 && nums[i] == nums[i-1]) continue;
            while(l<r){
                if(nums[l] + nums[r] == sum){
                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    //过滤后两个数重复的情况
                    while(l<r && nums[l] == nums[l+1]) l++;
                    while(l<r && nums[r] == nums[r-1]) r--;
                    l++;
                    r--;
                }else if(nums[l] + nums[r] < sum){
                    //减少重复循环
                    while(l<r && nums[l] == nums[l+1]) l++;
                    l++;
                }else{
                //减少重复循环
                    while(l<r && nums[r] == nums[r-1]) r--;
                    r--;
                }
            }
        }
        return res;
    }
```

