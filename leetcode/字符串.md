# 字符串

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

示例 1:

> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

> 输入: "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

> 输入: "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。

     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

**题解1：**

 维护一个滑动窗口，往右滑动：如果新加入的不会导致重复， 那么继续右扩，如果有重复，就左边收，直到没有

用hashmap存储最近一个重复的字符


    class Solution {
        public int lengthOfLongestSubstring(String s) {
            Map<Character, Integer> map = new HashMap<>();
            int cur =0, res=0;
    
            for(int i =0; i < s.length(); i++){
                //判断当前字符前一个重复字符的位置
                int left = map.getOrDefault(s.charAt(i), -1);
                //判断重复位置是否覆盖>当前最长字串，若未覆盖，当前+1
                cur = cur < i-left ? cur+1 : i-left;
                res = Math.max(res, cur);
                map.put(s.charAt(i), i); 
            }
            return res;
        }
    }
**题解2：**

用一个SET记录，当前最长子串的所有字符

实际上也是滑动窗口，和题解1思路一样，实现不同而已

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] chs = s.toCharArray();
        int len =chs.length;
        // 哈希集合，记录每个字符是否出现过
        Set<Character> recordSet = new HashSet<Character>();
        int r=-1,res=0;
        for (int i =0;i<len;i++){
            if (i!=0) recordSet.remove(chs[i-1]);
            //计算以（当前i为起点，上一时刻最长子串末尾为终点）出发的最长子串
            while(r+1<len && !recordSet.contains(chs[r+1])){
                recordSet.add(chs[r+1]);
                r++;
            }
            res = Math.max(res,r-i+1);
        }
        return res;
    }
}
```

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

> 输入: ["flower","flow","flight"]
> 输出: "fl"

示例 2:

> 输入: ["dog","racecar","car"]
> 输出: ""
> 解释: 输入不存在公共前缀。

说明:

所有输入只包含小写字母 a-z 。

题解1：

纵向比较：

```java
public String longestCommonPrefix(String[] strs) {
        if(strs.length < 1) return "";
        if(strs.length == 1) return strs[0];
        StringBuilder sb = new StringBuilder();
        for(int i =0; i<strs[0].length(); i++){
            for(int j =1; j<strs.length; j++){
                if(strs[j].length() < i+1 || strs[0].charAt(i) != strs[j].charAt(i)){
                    return sb.toString();
                }
            }
            sb.append(strs[0].charAt(i));
        }
        return sb.toString();
    }
```

#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

示例1:

> 输入: s1 = "ab" s2 = "eidbaooo"
> 输出: True
> 解释: s2 包含 s1 的排列之一 ("ba").


示例2:

> 输入: s1= "ab" s2 = "eidboaoo"
> 输出: False


注意：

输入的字符串只包含小写字母
两个字符串的长度都在 [1, 10,000] 之间

题解一：

哈希表（因为只有26个小写字母，用数组可提高效率）

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if(s2.length() < s1.length()) return false;
        //子串元素表
        int [] arr = new int[26];
        for(int i =0; i< s1.length(); i++){
            arr[s1.charAt(i)-'a']++;
        }
        for(int i=0; i <= (s2.length() - s1.length()); i++){
            //存储当前窗口的字符元素表
            int [] child = new int[26];
            for(int j=0;  j< s1.length(); j++){
                child[s2.charAt(i+j)-'a']++;
            }
            if(matched(arr, child)) return true;
        }
        return false;

    }
    //比较两个数组
    public boolean matched(int [] arr1, int[] arr2){
        for(int i =0; i<26; i++){
            if(arr1[i] != arr2[i]) return false;
        }
        return true;
    }
}
```

题解二：

滑动窗口，基于上面改造，S2只需要维护一个S1长度的滑动窗口，时间复杂度为O(n*(m-n));

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if(s2.length() < s1.length()) return false;
        int[] arr = new int[26];
        int[] wins = new int[26];
        for(int i =0; i<s1.length(); i++){
            arr[s1.charAt(i)-'a']++;
            wins[s2.charAt(i)-'a']++;
        }
        
        for(int i=0; i<s2.length()-s1.length(); i++){
            if(matched(arr, wins)) return true;
            wins[s2.charAt(i+s1.length())-'a']++;
            wins[s2.charAt(i)-'a']--;
        }
        return matched(arr, wins);
    }

    private boolean matched(int[] arr1, int[] arr2){
        for(int i=0; i<arr1.length; i++){
            if(arr1[i] != arr2[i]) return false;
        }
        return true;
    }
}
```

#### [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

示例 1:

> 输入: num1 = "2", num2 = "3"
> 输出: "6"

示例 2:

> 输入: num1 = "123", num2 = "456"
> 输出: "56088"

说明：

num1 和 num2 的长度小于110。
num1 和 num2 只包含数字 0-9。
num1 和 num2 均不以零开头，除非是数字 0 本身。
不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。

题解：

```java
public String multiply(String num1, String num2) {
     /**
        num1的第i位(高位从0开始)和num2的第j位相乘的结果在乘积中的位置是[i+j, i+j+1]
        例: 123 * 45,  123的第1位 2 和45的第0位 4 乘积 08 存放在结果的第[1, 2]位中
          index:    0 1 2 3 4  
              
                        1 2 3
                    *     4 5
                    ---------
                          1 5
                        1 0
                      0 5
                    ---------
                      0 6 1 5
                        1 2
                      0 8
                    0 4
                    ---------
                    0 5 5 3 5
        这样我们就可以单独都对每一位进行相乘计算把结果存入相应的index中        
        **/
        int n1 = num1.length();
        int n2 = num2.length();
        if(n1 == 0 || n2 == 0) return "";
        int[] res = new int[n1+n2]; 
        for(int i= n1-1; i>=0; --i){
            for(int j = n2-1; j>=0; --j){
                int bitmul = (num1.charAt(i)-'0')*(num2.charAt(j)-'0');
                bitmul += res[i+j+1];// 先加低位判断是否有新的进位
                res[i+j] += bitmul/10;
                res[i+j+1] = bitmul%10;
            }
        }
        StringBuilder sb = new StringBuilder();
        int pt =0;
        //去掉前导0
        while(pt<res.length-1 && res[pt]==0) pt++;
        for(; pt<res.length; ++pt) sb.append(res[pt]);
        return sb.toString();
    }
```

#### [767. 重构字符串](https://leetcode-cn.com/problems/reorganize-string/)

给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

示例 1:

> 输入: S = "aab"
> 输出: "aba"

示例 2:

> 输入: S = "aaab"
> 输出: ""

注意:

S 只包含小写字母并且长度在[1, 500]区间内。

题解：

大顶堆+hash表

```java
public String reorganizeString(String S) {
        int[] arr = new int[26];
        //定义大顶堆，堆顶为出现次数最多的字母
        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2)->arr[o2]-arr[o1]);
        for(int i =0; i<S.length(); ++i){
            arr[S.charAt(i) - 'a']++;
        }

        for(int i=0; i<26; i++){
            if(arr[i] >(S.length()+1)/2) return "";
            else if(arr[i] >0) pq.add(i);
        }
        char[] res = new char[S.length()];
        int index =0;
        //每次取出最高频和次高频的字母，并重新压入大顶堆
        while(pq.size()>1){
            int maxV = pq.poll();
            int secV = pq.poll();
            res[index++] = (char)(maxV+'a');
            res[index++] = (char)(secV+'a');
            if(--arr[maxV] >0) pq.add(maxV);
            if(--arr[secV] >0) pq.add(secV);
        }
        //单独处理最后一个元素
        if(pq.size() >0) res[index] = (char)(pq.poll()+'a');
        return String.valueOf(res);
    }
```