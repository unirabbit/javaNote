# 字符串

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

示例 1:

> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:

> 输入: "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:

> 输入: "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。

​     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

**题解1：**

 维护一个滑动窗口，往右滑动：如果新加入的不会导致重复， 那么继续右扩，如果有重复，就左边收，直到没有

用hashmap存储最近一个重复的字符

    
    class Solution {
        public int lengthOfLongestSubstring(String s) {
            Map<Character, Integer> map = new HashMap<>();
            int cur =0, res=0;
    
            for(int i =0; i < s.length(); i++){
                //判断当前字符前一个重复字符的位置
                int left = map.getOrDefault(s.charAt(i), -1);
                //判断重复位置是否覆盖>当前最长字串，若未覆盖，当前+1
                cur = cur < i-left ? cur+1 : i-left;
                res = Math.max(res, cur);
                map.put(s.charAt(i), i); 
            }
            return res;
        }
    }
**题解2：**

用一个SET记录，当前最长子串的所有字符

实际上也是滑动窗口，和题解1思路一样，实现不同而已

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] chs = s.toCharArray();
        int len =chs.length;
        // 哈希集合，记录每个字符是否出现过
        Set<Character> recordSet = new HashSet<Character>();
        int r=-1,res=0;
        for (int i =0;i<len;i++){
            if (i!=0) recordSet.remove(chs[i-1]);
            //计算以（当前i为起点，上一时刻最长子串末尾为终点）出发的最长子串
            while(r+1<len && !recordSet.contains(chs[r+1])){
                recordSet.add(chs[r+1]);
                r++;
            }
            res = Math.max(res,r-i+1);
        }
        return res;
    }
}
```





