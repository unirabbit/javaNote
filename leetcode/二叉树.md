# 二叉树

## [前中后序遍历](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 树.md#前中后序遍历)

- [1. 非递归实现二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

```java
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        LinkedList<TreeNode> dq = new LinkedList<>();
        dq.addFirst(root);
        while(!dq.isEmpty()){
            TreeNode node = dq.pollFirst();
            res.add(node.val);
            if(node.right!=null) dq.addFirst(node.right);
            if(node.left!=null) dq.addFirst(node.left);
            
        }
        return res;
    }
```



- [2. 非递归实现二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)



```java
public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if(root == null) return res;
        LinkedList<TreeNode> dq = new LinkedList<>();
        dq.addFirst(root);
        while(!dq.isEmpty()){
            TreeNode node = dq.pollFirst();
            res.addFirst(node.val);
            if(node.left!=null) dq.addFirst(node.left);
            if(node.right!=null) dq.addFirst(node.right);
        }
        return res;
    }
```
- [3. 非递归实现二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)

```java
public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> dq = new LinkedList<>();
        List<Integer> list = new LinkedList<>();
        if(root == null) return list;
        TreeNode node = root;
        while(node!= null ||!dq.isEmpty()){
            while(node!= null){
                dq.addLast(node);
                node = node.left;
            }
            node = dq.pollLast();
            list.add(node.val);
            node = node.right;
        }
        return list;
    }
```



## BST

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int num = getNum(root.left);
        if(num+1 == k) return root.val;
        return num+1 > k ?kthSmallest(root.left, k):kthSmallest(root.right, k-1-num);
    }
    
    public int getNum(TreeNode root){
        if(root == null) return 0;
        return 1+getNum(root.right)+getNum(root.left);
    }
}
```

