# 二叉树

## [前中后序遍历](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 树.md#前中后序遍历)

### [1. 非递归实现二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

```java
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        LinkedList<TreeNode> dq = new LinkedList<>();
        dq.addFirst(root);
        while(!dq.isEmpty()){
            TreeNode node = dq.pollFirst();
            res.add(node.val);
            if(node.right!=null) dq.addFirst(node.right);
            if(node.left!=null) dq.addFirst(node.left);
            
        }
        return res;
    }
```



### [2. 非递归实现二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)



```java
public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if(root == null) return res;
        LinkedList<TreeNode> dq = new LinkedList<>();
        dq.addFirst(root);
        while(!dq.isEmpty()){
            TreeNode node = dq.pollFirst();
            res.addFirst(node.val);
            if(node.left!=null) dq.addFirst(node.left);
            if(node.right!=null) dq.addFirst(node.right);
        }
        return res;
    }
```
### [3. 非递归实现二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)

```java
public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> dq = new LinkedList<>();
        List<Integer> list = new LinkedList<>();
        if(root == null) return list;
        TreeNode node = root;
        while(node!= null ||!dq.isEmpty()){
            while(node!= null){
                dq.addLast(node);
                node = node.left;
            }
            node = dq.pollLast();
            list.add(node.val);
            node = node.right;
        }
        return list;
    }
```

### 4.[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

 

参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true


提示：

数组长度 <= 1000

**题解：**

```java
public boolean verifyPostorder(int[] postorder) {
        return check(postorder, 0 , postorder.length-1);
    }

public boolean check(int[] postorder, int left, int right){
        if(left >= right) return true;
        int point = left;
        //获取左右子树的分界点
        while(postorder[point] < postorder[right]) point++;
        int i = point;
        //判断右子树是否合规
        while(i++ < right){
            if(postorder[i] < postorder[right]) return false;
        } 
        return check(postorder, left, point-1) && check(postorder, point, right -1);
    }
```



## BST

### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int num = getNum(root.left);
        if(num+1 == k) return root.val;
        return num+1 > k ?kthSmallest(root.left, k):kthSmallest(root.right, k-1-num);
    }
    
    public int getNum(TreeNode root){
        if(root == null) return 0;
        return 1+getNum(root.right)+getNum(root.left);
    }
}
```

### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

     3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

输入：A = [1,2,3], B = [3,1]
输出：false
示例 2：

输入：A = [3,4,5,1,2], B = [4,1]
输出：true
限制：

0 <= 节点个数 <= 10000

题解：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(null == A || null == B) return false;
        if(A.val  == B.val && fun(A, B)){
            return true;
        }
        return  isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }

    public boolean fun(TreeNode A, TreeNode B){
        if(null == B) return true;
        if(null == A) return false;
        if(A.val  == B.val){
            return fun(A.left, B.left) && fun(A.right, B.right);
        }
        return false;
    }
}
```

