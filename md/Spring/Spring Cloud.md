# Spring Cloud

## Eureka

### 基础概念

服务注册中心

- 失效剔除

  Eureka Server默认每隔一段时间(60S)将当前清单中超时(90S)未续约的服务剔除

- 自我保护

  当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。

服务提供者

- 服务注册

	当Eureka客户端向Eureka Server注册时，它提供自身的元数据，Server将其存储在一个双层Map中

- 服务同步

	多个注册中心互相注册成服务，同步注册请求

- 服务续约

	Eureka客户会每隔30秒发送一次心跳来续约

服务消费者

- 获取服务

	Eureka Server缓存一份只读服务清单给客户端，30S更新一次

- 服务调用

	客户端获取到服务清单后，由Ribbon进行负载均衡决定调用具体的服务实例

- 服务下线

	Eureka客户端在程序关闭时向Eureka服务器发送取消Rest请求，该客户端实例信息将从服务器的实例注册表中删除。

### 高可用

- 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。
- 多个服务注册中心互相注册，以实现服务清单的互相同步，达到高可用
- 客户端分为服务提供者和服务消费者，低耦合
- 失效剔除和自我保护机制

## Ribbon

### 负载均衡

- 独立进程单元通过负载均衡策略，将请求转发到不同的执行单元上，例如Ngnix 。
- 将负载均衡逻辑以代码的形式封装到服务消费者的客户端上，服务消费者客户端维护了一份服务提供者的信息列表，有了信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。例如Ribbon

#### **集中式负载均衡**

<img src="https://gitee.com/adambang/pic/raw/master/20201204110616.png" alt="image-20201204110610299" style="zoom: 60%;" />

客户端的请求信息并不会直接去请求服务实例，而是在到达负载均衡器的时候，通过负载均衡算法选择某一个服务实例，然后将请求转发到这个服务实例上。

集中式负载均衡又分为硬件负载均衡，如F5，软件负载均衡,如Nginx。

#### **客户端负载均衡**

<img src="https://gitee.com/adambang/pic/raw/master/20201204110734.png" alt="image-20201204110734241" style="zoom: 50%;" />

客户端请求不会再去负载均衡器上进行转发了，客户端自己维护了一套服务列表，要掉用的某个服务实例之前首先会通过负载均衡算法选择一个服务节点，直接将请求发送到该服务节点上。

- 是通过Ribbon的ILoadBalancer接口实现
### 总体架构

<img src="https://gitee.com/adambang/pic/raw/master/20201204111145.png" alt="image-20201204111145034" style="zoom:60%;" />

- ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API 。
- ribbon-eureka ：Ribbon 结合Eureka 客户端的API ，为负载均衡器提供动态服务注册列表信息。
- ribbon-core: Ribbon 的核心API 。

### Feign

- 声明式的web service客户端
- 集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端

## Hystrix

### 服务雪崩

- 微服务架构下，会存在服务之间相互依赖调用的情况，当某个服务不可用时，很容易因为服务之间的依赖关系使故障扩大，甚至造成整个系统不可用的情况，这种现象称为服务雪崩效应。
- Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延

### 设计原则

- 避免线程失败

	由于被调用方出现问题，调用方无法及时获取响应结果，而一直在发送请求，最终会耗尽所有线程的资源

- 快速失败

	当被调用方出现问题后，调用方发起的请求可以快速失败并返回，这样就不用一直阻塞住，同时也释放了线程资源。

- 支持回退

	在失败后，我们可以让用户有回退的逻辑，比如获取备用数据，从缓存中获取数据，记录日志等操作

- 资源隔离
- 近实时监控

### 高可用/容错

#### 资源隔离

资源隔离，就是说，你如果要把对某一个依赖服务的所有调用请求，全部隔离在同一份资源池内，不会去用其它资源了，这就叫资源隔离。Hystrix 进行资源隔离，其实是提供了一个抽象，叫做 command。这也是 Hystrix 最最基本的资源隔离技术。

依赖隔离是Hystrix的核心目的。依赖隔离其实就是资源隔离，把对依赖使用的资源隔离起来，统一控制和调度。那为什么需要把资源隔离起来呢？主要有以下几点：

1. 合理分配资源，把给资源分配的控制权交给用户，某一个依赖的故障不会影响到其他的依赖调用，访问资源也不受影响。

2. 可以方便的指定调用策略，比如超时异常，熔断处理。

3. 对依赖限制资源也是对下游依赖起到一个保护作用，避免大量的并发请求在依赖服务有问题的时候造成依赖服务瘫痪或者更糟的雪崩效应。

4. 对依赖调用进行封装有利于对调用的监控和分析，类似于hystrix-dashboard的使用。

Hystrix将远程服务的请求托管在一个线程池中。即默认情况下，所有Hystrix命令(@HystrixCommand)共享同一个线程池来处理这些请求。而Hystrix配置@HystrixCommand内的参数后通过线程池/信号量对依赖的服务进行隔离。

##### 线程池隔离

Hystrix提供了简单易用的方法实现**舱壁模式**来隔离不同的远程资源调用。线程池隔离，Hystrix可以为每一个依赖建立一个线程池，使之和其他依赖的使用资源隔离，同时限制他们的并发访问和阻塞扩张。每个依赖可以根据权重分配资源（这里主要是线程），每一部分的依赖出现了问题，也不会影响其他依赖的使用资源。调用过程如下图：

<img src="https://img2018.cnblogs.com/blog/285763/201809/285763-20180920160353139-1937243496.jpg" alt="img" style="zoom: 80%;" />

示例代码：

```java
@HystrixCommand(
        fallbackMethod = "buildFallbackLicenseList",
        threadPoolKey = "licenseByOrgThreadPool",
        threadPoolProperties = {
            @HystrixProperty(name = "coreSize",value="30"),
            @HystrixProperty(name="maxQueueSize", value="10")
        }
)
public List<License> getLicensesByOrg(String organizationId){
    randomlyRunLong();
    return licenseRepository.findByOrganizationId(organizationId);
}
```

**优点：**

- 一个依赖可以给予一个线程池，这个依赖的异常不会影响其他的依赖。
- 使用线程可以完全隔离第三方代码,请求线程可以快速放回。
- 当一个失败的依赖再次变成可用时，线程池将清理，并立即恢复可用，而不是一个长时间的恢复。
- 可以完全模拟异步调用，方便异步编程。
- 使用线程池，可以有效的进行实时监控、统计和封装。

**缺点：**

- 使用线程池的缺点主要是增加了计算的开销。每一个依赖调用都会涉及到队列，调度，上下文切换，而这些操作都有可能在不同的线程中执行。

##### 信号量隔离

信号量的资源隔离只是起到一个开关的作用，例如，服务X的信号量大小为10，那么同时只允许10个tomcat的线程(此处是tomcat的线程，而不是服务X的独立线程池里面的线程)来访问服务X，其他的请求就会被拒绝，从而达到限流保护的作用。

##### 线程池与信号量区别

线程池隔离技术，并不是说去控制类似 tomcat 这种 web 容器的线程。更加严格的意义上来说，Hystrix 的线程池隔离技术，控制的是 tomcat 线程的执行。Hystrix 线程池满后，会确保说，tomcat 的线程不会因为依赖服务的接口调用延迟或故障而被 hang 住，tomcat 其它的线程不会卡死，可以快速返回，然后支撑其它的事情。

线程池隔离技术，是用 Hystrix 自己的线程去执行调用；而信号量隔离技术，是直接让 tomcat 线程去调用依赖服务。信号量隔离，只是一道关卡，信号量有多少，就允许多少个 tomcat 线程通过它，然后去执行。

**适用场景**：

- **线程池技术**，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。
- **信号量技术**，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。

区别：

|              | 线程池隔离                                                   | 信号量隔离                                                   |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 线程         | 与调用线程非相同线程                                         | 与调用线程相同（jetty线程）                                  |
| 开销         | 排队、调度、上下文开销等                                     | 无线程切换，开销低                                           |
| 异步         | 可以是异步，也可以是同步。看调用的方法                       | 同步调用，不支持异步                                         |
| 并发支持     | 支持（最大线程池大小hystrix.threadpool.default.maximumSize） | 支持（最大信号量上限maxConcurrentRequests）                  |
| 是否超时     | 支持，可直接返回                                             | 不支持，如果阻塞，只能通过调用协议（如：socket超时才能返回） |
| 是否支持熔断 | 支持，当线程池到达maxSize后，再请求会触发fallback接口进行熔断 | 支持，当信号量达到maxConcurrentRequests后。再请求会触发fallback |
| 隔离原理     | 每个服务单独用线程池                                         | 通过信号量的计数器                                           |
| 资源开销     | 大，大量线程的上下文切换，容易造成机器负载高                 | 小，只是个计数器                                             |

#### 服务熔断

熔断机制是应对雪崩效应的一种微服务链路保护机制，

当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路，在SpringCloud框架机制通过Hystrix实现，Hystrix会监控微服务见调用的状况，当失败的调用到一个阈值，缺省是5秒内20次调用失败就会启动熔断机制，熔断机制的注解是@HystrixCommand。

#### 服务降级

整体资源快不够用了，忍痛将某些服务先关掉，待度过难关，再回来开启。

所谓降级，就是一般是从整体符合考虑，就是当某个服务熔断之后，服务器将不再被调用，此刻客户端可以自己准备一个本地的fallback回调，返回一个缺省值，这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强。

重载getFallback()方法，然后在@HystrixCommand中定义fallbackMethod。

#### 服务监控

可以利用hystrix来达到实时的服务监控的功能。

### 高并发

##### 请求缓存

请求缓存保证在一次请求中多次调用同一个服务提供者接口，在cacheKey不变的情况下，后续调用结果都是第一次的缓存结果，而不是多次请求服务提供者，从而降低服务提供者处理重复请求的压力。

##### 请求合并

Hystrix的请求合并就是把重复的请求批量的用一个HystrixCommand命令去执行，以减少通信消耗和线程数的占用。Hystrix的请求合并用到了HystrixCollapser这个抽象类，它在HystrixCommand之前前放置一个合并处理器，将处于一个很短的时间窗(默认10ms)内对同一依赖服务的多个请求进行整合并以批量方式发起请求的功能（服务提供方也需要提供相应的批量实现接口）。

### 实现流程

1.构建HystrixCommand或者HystrixObservableCommand对象

2.执行命令（即上述 Command 对象包装的逻辑）

3.结果是否有缓存

4.断路器是否打开

5.线程池/请求队列/信号量是否占满

6.使用HystrixObservableCommand.construct()还是HystrixCommand.run()

7.计算链路健康度

8.失败回退逻辑

> 有以下几种情况是会调用fallback降级机制的。
>        1.断路器打开 2.线程池或者信号量已经满了 3.command执行异常 4.执行超时

9.返回正常回应

## 路由网关(zuul)

在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服务。服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。

Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如/api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能
