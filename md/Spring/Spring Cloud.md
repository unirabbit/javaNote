# Spring Cloud

## Eureka

### 基础概念

服务注册中心

- 失效剔除

  Eureka Server默认每隔一段时间(60S)将当前清单中超时(90S)未续约的服务剔除

- 自我保护

  当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。

服务提供者

- 服务注册

	当Eureka客户端向Eureka Server注册时，它提供自身的元数据，Server将其存储在一个双层Map中

- 服务同步

	多个注册中心互相注册成服务，同步注册请求

- 服务续约

	Eureka客户会每隔30秒发送一次心跳来续约

服务消费者

- 获取服务

	Eureka Server缓存一份只读服务清单给客户端，30S更新一次

- 服务调用

	客户端获取到服务清单后，由Ribbon进行负载均衡决定调用具体的服务实例

- 服务下线

	Eureka客户端在程序关闭时向Eureka服务器发送取消Rest请求，该客户端实例信息将从服务器的实例注册表中删除。

### 高可用

- 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。
- 多个服务注册中心互相注册，以实现服务清单的互相同步，达到高可用
- 客户端分为服务提供者和服务消费者，低耦合
- 失效剔除和自我保护机制

## Ribbon

### 负载均衡

- 独立进程单元通过负载均衡策略，将请求转发到不同的执行单元上，例如Ngnix 。
- 将负载均衡逻辑以代码的形式封装到服务消费者的客户端上，服务消费者客户端维护了一份服务提供者的信息列表，有了信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。例如Ribbon

#### **集中式负载均衡**

<img src="https://gitee.com/adambang/pic/raw/master/20201204110616.png" alt="image-20201204110610299" style="zoom: 60%;" />

客户端的请求信息并不会直接去请求服务实例，而是在到达负载均衡器的时候，通过负载均衡算法选择某一个服务实例，然后将请求转发到这个服务实例上。

集中式负载均衡又分为硬件负载均衡，如F5，软件负载均衡,如Nginx。

#### **客户端负载均衡**

<img src="https://gitee.com/adambang/pic/raw/master/20201204110734.png" alt="image-20201204110734241" style="zoom: 50%;" />

客户端请求不会再去负载均衡器上进行转发了，客户端自己维护了一套服务列表，要掉用的某个服务实例之前首先会通过负载均衡算法选择一个服务节点，直接将请求发送到该服务节点上。

- 是通过Ribbon的ILoadBalancer接口实现
### 总体架构

<img src="https://gitee.com/adambang/pic/raw/master/20201204111145.png" alt="image-20201204111145034" style="zoom:60%;" />

- ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API 。
- ribbon-eureka ：Ribbon 结合Eureka 客户端的API ，为负载均衡器提供动态服务注册列表信息。
- ribbon-core: Ribbon 的核心API 。

### Feign

- 声明式的web service客户端
- 集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端

## Hystrix

### 服务雪崩

- 微服务架构下，会存在服务之间相互依赖调用的情况，当某个服务不可用时，很容易因为服务之间的依赖关系使故障扩大，甚至造成整个系统不可用的情况，这种现象称为服务雪崩效应。
- Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延

### 设计原则

- 避免线程失败

	由于被调用方出现问题，调用方无法及时获取响应结果，而一直在发送请求，最终会耗尽所有线程的资源

- 快速失败

	当被调用方出现问题后，调用方发起的请求可以快速失败并返回，这样就不用一直阻塞住，同时也释放了线程资源。

- 支持回退

	在失败后，我们可以让用户有回退的逻辑，比如获取备用数据，从缓存中获取数据，记录日志等操作

- 资源隔离
- 近实时监控

### 高可用

- 服务降级

	重载getFallback()方法

- 服务熔断
- 请求缓存
- 请求合并
- 服务监控
- 依赖隔离

	线程池/信号量对依赖的服务进行隔离

### 实现流程

1.构建HystrixCommand或者HystrixObservableCommand对象

2.执行命令（即上述 Command 对象包装的逻辑）

3.结果是否有缓存

4.断路器是否打开

5.线程池/请求队列/信号量是否占满

6.使用HystrixObservableCommand.construct()还是HystrixCommand.run()

7.计算链路健康度

8.失败回退逻辑

> 有以下几种情况是会调用fallback降级机制的。
>        1.断路器打开 2.线程池或者信号量已经满了 3.command执行异常 4.执行超时

9.返回正常回应

## 路由网关(zuul)

在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。

Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如/api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能

*XMind - Trial Version*