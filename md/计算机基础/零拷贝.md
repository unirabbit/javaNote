![image-20210119161418204](https://gitee.com/adambang/pic/raw/master/20210119161418.png)

# 一. DMA

DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依于CPU的大量中断负载。否则，CPU需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU对于其他的工作来说就无法使用。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，能使CPU 的效率大为提高。

![image-20210119161814659](https://gitee.com/adambang/pic/raw/master/20210119161814.png)

1. 要把内存数据发送到网卡然后发出去时：

   没有DMA时：CPU读**内存**数据到**CPU的高速缓存**，再写到网卡。这样就把CPU的速度拉低到和网卡一个速度。

   有了DMA：把内存数据读到socket内核缓存区（CPU复制），CPU就不管了，告诉DMA开始接管。DMA开始把内核缓冲区的数据写到网卡。DMA读socket缓冲区，读到DMA缓冲区，然后写到网卡中。不停写到网卡。

   DMA发送完后，DMA中断CPU，（这样CPU就知道socket内核缓冲区又空出来了），CPU从用户态切换到内核态，执行中断处理程序，将socket缓冲区阻塞的进程移回到运行队列。

   比如要发送的数据是100k，但是内核缓冲区就50k，这样第二次50k也能发出去了。

2. 读硬件时：

   CPU检查内核缓冲区里是否有指定的数据，直接就可以读。如果没有，CPU就交给DMA，DMA负责把硬盘读到缓冲区，然后告诉CPU移动完了，然后把阻塞的进程再移动到运行队列。

# 二. 用户态/内核态切换

状态切换：

**\- 用户空间**：用户代码、用户堆栈
\- **内核空间**：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info进程描述符）
  \- 进程描述符和用户的进程是一一对应的
  \- SYS_API：系统调用，如read、write
  \- 进程描述符：进程从用户态切换到内核态时，需要保存用户态时的上下文信息，比如：用户程序基地址，程序计数器、cpu cache、寄存器。方便程序从内核态切换回用户态时恢复现场。
  \- 内核堆栈：系统调用函数也是要创建变量的，这些变量在内核堆栈上分配，

![image-20210119183610148](https://gitee.com/adambang/pic/raw/master/20210119183610.png)

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。

## 2.1 切换方式

内核态和用户态之间的**转换方式**主要包括：系统调用，异常和中断。

1. 系统调用

   这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。

2. 异常

   当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。

3. 外围设备的中断

   当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

## 2.2 切换操作

从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：

1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。

2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

## 2.3 系统调用

如果用户态程序需要执行系统调用，就需要执行中断切换到内核态执行。

> 比如用户想要读取硬盘上的文件，发起read调用，这个read只是内核态的库函数api，该库函数会发起系统调用。该库函数里面有80中断，软中断，进程切换到内核态。到cpu里存一个系统调用号（表示哪个系统函数，比如read）。把cpu的临时数据都保存到thread_info中（恢复到用户态时用），然后执行80中断处理程序，找到刚刚存的系统调用号（比如read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间，然后恢复到用户态，恢复现场，用户态就知道从哪继续执行。

系统调用过程如下图：

![image-20210119184224056](https://gitee.com/adambang/pic/raw/master/20210119184224.png)

## 2.4 中断操作

中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。

中断一般有三类，

一种是由CPU外部引起的，如I/O中断、时钟中断；

一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出；

最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。

# 三. 零拷贝基础

## 3.1 缓冲区

**读操作**：用户态切换到内核态，先看内核态缓冲区有没有，有就直接读到，没有就交给DMA去读。DMA控制器从磁盘、网卡、其他IO设备中读。CPU在这个期间可以执行其他进程。DMA加载到内核缓冲区后告诉CPU，CPU把数据拷贝到用户态，CPU把该进程从阻塞队列移到到运行队列。
**写操作**：内核缓冲区满了之后，写操作阻塞，缓冲区有一个等待队列，记录阻塞的进程（对应java的轻量级进程），DMA把缓冲区数据写到网卡后告诉CPU，中断CPU，把该进程移动到CPU中相关的运行队列。

![image-20210119190551095](https://gitee.com/adambang/pic/raw/master/20210119190551.png)

## 3.2 虚拟内存

**物理内存**

用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。是一块连续的存储空间。

<img src="https://gitee.com/adambang/pic/raw/master/20210119192643.png" alt="image-20210119192642968" style="zoom: 67%;" />

![image-20210119193354350](https://gitee.com/adambang/pic/raw/master/20210119193354.png)

**虚拟内存**

实际上的使用内存，会使用到硬盘上的内存。虚拟内存是一个现代CPU及操作系统为了管理不同进程使用的进程内部内存地址和物理内存地址的**映射体系**。

以前单核计算机时只需要保证保证不写内核空间即可。多核计算机引入多进程后，每个进程有自己的用户空间，得防止不能访问其他进程空间。所以引入了虚拟内存。进程分配了虚拟内存，CPU MMU单元可以帮助完成虚拟内存到物理内存的映射。虚拟内存可以大于真实物理内存，MMU可以使用一个LRU算法将最近最少使用的内存放到磁盘上（swap区），极限情况下活跃内存也会用到磁盘空间。

![image-20210119193649949](https://gitee.com/adambang/pic/raw/master/20210119193650.png)

因为可以替换，所以不同进程的虚拟内存空间的地址可以映射到用一个物理内存。利用这个特性，可以把用户空间和内核空间的地址翻译为同一块物理内存地址，就可以减少拷贝，即**零拷贝**的技术。

![image-20210119194534384](https://gitee.com/adambang/pic/raw/master/20210119194534.png)

## 3.3 BIO

从硬盘读到网卡，从左下到右下。进程去读，先看内核缓冲区有没有，没有就告诉DMA去读到内核缓冲区，然后把进程放到内核的阻塞队列中，DMA读好后发起中断告诉CPU，CPU唤醒阻塞进程，从内核缓冲区读到用户数据缓冲区，然后再切换到内核态进程写操作，写到socket缓冲区后，告诉DMA把socket缓冲区的数据写到网卡。复制了4次，进程切换了4次。![image-20210119200816030](https://gitee.com/adambang/pic/raw/master/20210119200816.png)

## 3.4 mmap

DMA把磁盘上的文件映射到内存，用户空间和内核空间共享同一块物理地址，这样就无需进程用户空间和内核空间的来回复制。写到网卡的时候，共享空间的内容拷贝到socket缓冲区（CPU复制），然后告诉DMA发送到网卡。3次复制（2次DMA，一次CPU复制）。

![image-20210119201328473](https://gitee.com/adambang/pic/raw/master/20210119201328.png)

## 3.5 sendfile

内核态切换到用户态将打开文件的fd和socket的fd告诉sendfile，也是经过和上面一样的3次复制。不过只进行了2次用户态和内核态的切换。

![image-20210119201739387](https://gitee.com/adambang/pic/raw/master/20210119201739.png)