# JVM类加载

### 类的生命周期

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化  ,如下图：

![image-20201113111721452](https://gitee.com/adambang/pic/raw/master/20201113111721.png)

1. **加载**

加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对
象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既
可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），
也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）  

2. **连接**

   - **验证**

     这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并
     且不会危害虚拟机自身的安全。  

     验证字节码文件的正确性，包括： 1.文件格式验证； 2.元数据验证；3.字节码验证；4.符号引用验证

   - **准备**

     准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使
     用的内存空间。

   - **解析**

     虚拟机将常量池中的符号引用替换为直接引用【类装载器装入类所引用的其它所有类(静态链接)】

3. **初始化**

对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）>（变量、初始化块）>构造器。

2. **使用**
3. **卸载**

### 类加载器

- 启动类加载器(Bootstrap ClassLoader)

- 扩展类加载器(Extension ClassLoader)

- 应用程序类加载器(Application ClassLoader)

- 自定义类加载器

  **双亲委派**

  当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。

  ![image-20201113140630125](https://gitee.com/adambang/pic/raw/master/20201113140630.png)
# JVM内存空间

JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区
域【JAVA 堆、方法区】、直接内存。  

![image-20201214192706483](https://gitee.com/adambang/pic/raw/master/20201214192706.png)

# JVM垃圾回收机制

## 判断对象存活

#### 引用计数算法

- 强引用

  就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收。

- 软引用

  软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生 OutOfMemory 时，肯定是没有软引用存在的。

- 弱引用

  弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。

- 虚引用

  作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。

#### 可达性分析算法(GC Roots)

- JVM中局部变量表中引用的对象
- 方法区中的静态引用、常量引用
- JNI引用的对象

## 垃圾回收方法

#### 标记清除

Mark-Sweep

- 分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清
  除阶段回收被标记的对象所占用的空间。此算法需要暂停整个应用，
  同时，会产生内存碎片。
- 缺点：效率不稳定，内存碎片化

#### 标记复制

Mark-Copying

- 按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
- 优点：实现简单，内存效率高，不易产生碎片。
- 缺点：可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。

#### 标记整理

Mark-Compact

- 标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。

#### 分代收集

- 新生代：标记复制算法
- 老年代：标记清理/整理算法

# JVM垃圾收集器

回收类型

- Minor GC：发生在年轻代的 GC
- Major GC：发生在老年代的 GC
- Full GC：全堆垃圾回收

## CMS

- 年轻代使用复制算法，而对老年代使用标记-清除算法

- 回收过程

  - 初始标记

    只标记直接关联 GC root的对象，不用向下追溯，速度快

  - 并发标记

    标记 GC root所有可达的对象，和用户线程并行

  - 重新标记

    修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要暂停所有的工作线程。

  - 并发清理

    清除GC Roots不可达对象，和用户线程并行

- STW

  1.初始标记，这部分的停顿时间较短；

  2.Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定；

  3.重新标记，由于 preclaen 阶段的介入，这部分停顿也较短；

  4.Serial-Old 收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长；

  5.Full GC，永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长。

- 优势

  - 低延迟，尤其对于大堆来说。大部分垃圾回收过程并发执行。

- 劣势

  - 内存碎片问题。Full GC 的整理阶段，会造成较长时间的停顿。
  - 需要预留空间，用来分配收集阶段产生的“浮动垃圾”。
  - 使用更多的 CPU 资源，在应用运行的同时进行堆扫描。

## G1

- G1（复制+标记清除）收集器是JDK9的默认垃圾收集器，而且不再区分年轻代和老年代进行回收。

- G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。

- 回收过程

  - 初始标记

    标记了从GC Root开始直接可达的对象

  - 并发标记

    从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息

  - 最终标记

    标记那些在并发标记阶段发生变化的对象，将被回收

  - 筛选回收

    清除空Region（没有存活对象的），加入到free list