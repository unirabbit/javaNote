# JVM类加载

### 类的生命周期

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化  ,如下图：

![image-20201113111721452](https://gitee.com/adambang/pic/raw/master/20201113111721.png)

1. **加载**

加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对
象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既
可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），
也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）  

2. **连接**

   - **验证**

     这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并
     且不会危害虚拟机自身的安全。  

     验证字节码文件的正确性，包括： 1.文件格式验证； 2.元数据验证；3.字节码验证；4.符号引用验证

   - **准备**

     准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使
     用的内存空间。

   - **解析**

     虚拟机将常量池中的符号引用替换为直接引用【类装载器装入类所引用的其它所有类(静态链接)】

3. **初始化**

对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）>（变量、初始化块）>构造器。

2. **使用**
3. **卸载**

### 类加载器

- 启动类加载器(Bootstrap ClassLoader)

- 扩展类加载器(Extension ClassLoader)

- 应用程序类加载器(Application ClassLoader)

- 自定义类加载器

  **双亲委派**

  当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。

  ![image-20201113140630125](https://gitee.com/adambang/pic/raw/master/20201113140630.png)
# JVM内存空间

![image-20201214202657184](https://gitee.com/adambang/pic/raw/master/image-20201214202657184.png)

JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。  

<img src="https://gitee.com/adambang/pic/raw/master/image-20201214202919021.png" alt="image-20201214202919021" style="zoom: 60%;" />

综合以上内容，类中方法执行的过程如下：

![image-20201216104916755](https://gitee.com/adambang/pic/raw/master/20201216104916.png)

## 1.程序计数器（线程私有）

 程序计数器（Program Counter Register），也有称作为PC寄存器。保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加 1 或者根据转移指针得 到下一条指令的地址，如此循环，直至执行完所有的指令。也就是说是用来指示执行哪条指令的。

由于在 JVM中，<u>多线程是通过线程轮流切换来获得 CPU执行时间的</u>，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序 计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，**程序计数器是每个线程所私有的**。

 在JVM规范中规定，如果线程执行的是**非 native** 方法，则程序计数器中保存的是当 前需要执行的指令的地址；如果线程执行的是 **native** 方法，则程序计数器中的值是 undefined。

由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此， 对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。 

**异常情况**： 不存在

## 2.虚拟机栈（线程私有）

<img src="https://gitee.com/adambang/pic/raw/master/image-20201214204513691.png" alt="image-20201214204513691" style="zoom: 67%;" />

虚拟机栈中存放的是一个个的**栈帧**，每个栈帧对应一个被调用的方法，在栈帧中包括**局部变量表、操作数栈、动态链接、方法返回地址、 额外的附加信息**。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应 的栈帧必定位于 Java 栈的顶部。

> - 局部变量表：用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数
>   形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是 指向对象的引用。局部变量表的大小在编译器就可以确定其大小了。
> - 操作数栈：程序中的所有计算过程都是在借助于操作数栈来完成的。
> - 动态链接：指向**运行时常量池**中该栈帧所属方法的引用，将符号引用在运行期间转化为直接引用。
> - 方法返回地址：当一个方法执行完毕之后，要返回之前调用它的地方。

异常情况：

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度（递归嵌套方法）：StackOverflowError 
2. 不断创建线程，如果虚拟机在扩展栈时无法申请到足够的内存空间：OutOfMemoryError

## 3.本地方法栈（线程私有）

本地方法栈与 Java 栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行**本地方法（Native Method）**服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以 自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

异常情况： 

1. 栈深度大于已有深度：StackOverflowError 
2. 可扩展深度大于能够申请的内存：OutOfMemoryError

## 4.堆（线程共享）

堆是被线程共享的一块内存区域，**创建的对象和数组**都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM采用分代收集算法, 因此 Java堆从GC的角度还可以细分为: 新生代(Eden区、From Survivor区和To Survivor区)和老年代。

![image-20201214212726488](https://gitee.com/adambang/pic/raw/master/image-20201214212726488.png)

**异常情况：** 

可以处于物理上不连续的内存空间，逻辑连续即可。既可实现固定大小，也可扩展。如果堆中没有内存 完成实例分配，并且堆无法再扩展是，将会抛出 OutOfMemoryError。

## 5.方法区（线程共享）

即我们常说的**永久代**(Permanent Generation), 用于存储**被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区, 这样HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于**存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。

异常情况： 

1. 方法区调用递归，内存会溢出，报 OutOfMemoryError； 
2. .当常量池无法再申请到内存时 OutOfMemoryError



**方法区的回收：**

方法区（Hotspot虚拟机中的永久代）的垃圾回收主要收集两部分的内容：**废弃常量**和**无用的类**。

废弃常量的回收

以常量池中字面量的回收为例，假如一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个string对象叫作“abc”，即没有任何string对象引用常量池中的“abc”常量，也没有其他地方引用这个字面量。如果这时候发生内存回收，且有必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的类（接口），方法，字段的符号引用回收也类似。

类的回收

1. 首先该类的所有实例对象都已经从Java堆内存里被回收
2. 其次加载这个类的ClassLoader已经被回收
3. 最后，对该类的Class对象没有任何引用  

# JVM垃圾回收机制

## 判断对象存活

#### 引用计数算法

- 强引用

  就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收。

- 软引用

  软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生 OutOfMemory 时，肯定是没有软引用存在的。

- 弱引用

  弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。

- 虚引用

  作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。

#### 可达性分析算法(GC Roots)

Java通过可达性分析算法来达到标记存活对象的目的，定义一系列的GC ROOT为起点，从起点开始向下开始搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。

- JVM中局部变量表中引用的对象
- 方法区中的静态引用、常量引用
- 本地方法栈native方法(JNI)引用的对象

## 垃圾回收方法

#### 标记清除

Mark-Sweep

- 分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清
  除阶段回收被标记的对象所占用的空间。此算法需要暂停整个应用，
  同时，会产生内存碎片。
- 缺点：效率不稳定，内存碎片化

#### 标记复制

Mark-Copying

- 按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
- 优点：实现简单，内存效率高，不易产生碎片。
- 缺点：可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。

#### 标记整理

Mark-Compact

- 标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。

#### 分代收集

- 新生代：标记复制算法
- 老年代：标记清理/整理算法

# JVM垃圾收集器

回收类型

- Minor GC：发生在年轻代的 GC

- Major GC：发生在老年代的 GC

- Full GC：全堆垃圾回收

  <img src="https://gitee.com/adambang/pic/raw/master/b1e72c2c8555495c994bd7bbcfdac4c0~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom: 50%;" />

## ParNew  

G1回收器之前，线上系统都是ParNew垃圾回收器作为新生代的垃圾回收器。  

新生代的ParNew垃圾回收器主打的就是**多线程垃圾回收机制**，另外一种Serial垃圾回收器主打的是单线程垃圾回收，二者都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。  

指定了使用ParNew垃圾回收器之后，默认设置的垃圾回收线程的数量跟CPU的核数是一样的。  

![image-20201216102423971](C:\Users\zhaozhixiang\AppData\Roaming\Typora\typora-user-images\image-20201216102423971.png)

## CMS

CMS是老年代垃圾收集器，基于**标记-清除**算法,在收集过程中可以与用户线程并发操作。它可以与Serial收集器和Parallel New收集器搭配使用。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。可以通过JVM启动参数：`-XX:+UseConcMarkSweepGC`来开启CMS。

回收过程

- 初始标记(STW)

  只标记直接关联 GC root的对象，不用向下追溯，速度快

- 并发标记

  标记 GC root所有可达的对象，和用户线程并行

- 重新标记(STW)

  修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要暂停所有的工作线程。

- 并发清理

  清除GC Roots不可达对象，和用户线程并行

STW

1.初始标记，这部分的停顿时间较短；

2.Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定；

3.重新标记，由于 preclaen 阶段的介入，这部分停顿也较短；

4.Serial-Old 收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长；

5.Full GC，永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长。

优势

- 低延迟，尤其对于大堆来说。大部分垃圾回收过程并发执行。

劣势

- 内存碎片问题。Full GC 的整理阶段，会造成较长时间的停顿。
- 需要预留空间，用来分配收集阶段产生的“浮动垃圾”。
- 使用更多的 CPU 资源，在应用运行的同时进行堆扫描。

## G1

G1（复制+标记清除）收集器是JDK9的默认垃圾收集器，而且不再区分年轻代和老年代进行回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。

回收过程

- 初始标记

  标记了从GC Root开始直接可达的对象，此阶段需要停顿线程，但是耗时很短

- 并发标记

  从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息

- 最终标记

  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。

- 筛选回收

  更新Region的统计数据，对每个Region的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的Region中存活对象复制到空的Region，同时清理旧的Region。需要STW。

<u>总的来说除了并发标记之外，其他几个过程也还是需要短暂的STW，G1的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。</u>

## 总结

- 如果你的堆大小不是很大（比如 100MB），选择串行收集器一般是效率最高的。参数：-XX:+UseSerialGC。

- 如果你的应用运行在单核的机器上，或者你的虚拟机核数只有 1C，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。参数：-XX:+UseSerialGC。

- 如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。参数：-XX:+UseParallelGC。

- 如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。参数：-XX:+UseConcMarkSweepGC、-XX:+UseG1GC、-XX:+UseZGC 等。

# GC调优

## GC的时机

当一个新的对象来申请内存空间的时候，如果Eden区无法满足内存分配需求，则触发YGC，使用中的Survivor区和Eden区存活对象送到未使用的Survivor区，如果YGC之后还是没有足够空间，则直接进入老年代分配，如果老年代也无法分配空间，触发FGC，FGC之后还是放不下则报出OOM异常。

<img src="https://gitee.com/adambang/pic/raw/master/20201216092823.jpeg" alt="img" style="zoom: 43%;" />

Young GC其实一般就是在新生代的Eden区域不够之后就会触发，采用标记-复制算法来回收新生代的垃圾  

**对象进入老年代：**

1. 如果对象够老，会通过“提升”进入老年代。

   > 对于那些一直在Survivor区来回复制的对象，通过-XX：MaxTenuringThreshold配置交换阈值，默认15次，如果超过次数同样进入老年代。

2. 当 Survivor 空间不够，就需要依赖老年代进行分配担保。

3. 大对象直接在老年代分配

4. 动态年龄的判断机制。

   > 不需要等到MaxTenuringThreshold就能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

## 调优

### 核心参数

-Xms：Java堆内存的大小
-Xmx：Java堆内存的最大大小
-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
-XX:PermSize：方法区大小
-XX:MaxPermSize：方法区最大大小
-Xss：每个线程的栈内存大小  

### 日志输出

| 参数                          | 意义                                                       |
| ----------------------------- | ---------------------------------------------------------- |
| -verbose:gc                   | 打印 GC 日志                                               |
| PrintGCDetails                | 打印详细 GC 日志                                           |
| PrintGCDateStamps             | 系统时间，更加可读，PrintGCTimeStamps 是 JVM 启动时间      |
| PrintGCApplicationStoppedTime | 打印 STW 时间                                              |
| PrintTenuringDistribution     | 打印对象年龄分布，对调优 MaxTenuringThreshold 参数帮助很大 |
| loggc                         | 将以上 GC 内容输出到文件中                                 |

OOM 时的参数：

| 参数                       | 意义                       |
| -------------------------- | -------------------------- |
| HeapDumpOnOutOfMemoryError | OOM 时 Dump 信息，非常有用 |
| HeapDumpPath               | Dump 文件保存路径          |
| ErrorFile                  | 错误日志存放路径           |