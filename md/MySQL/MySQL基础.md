# Mysql基础 

## 基础架构

MySQL 的基本架构示意图如下：

<img src="https://gitee.com/adambang/pic/raw/master/20201110162214.png" alt="img" style="zoom: 25%;" />

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

SQL语句的整体执行细节如下图：

<img src="https://gitee.com/adambang/pic/raw/master/20201110165708.png" alt="image-20201110165708521" style="zoom: 67%;" />

在SQL执行过程中，组件的作用如下：

1. **连接器**

第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。

建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用*长连接*。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

怎么解决这个问题呢？可以考虑以下两种方案。

- 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
- 如果用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

2. **查询缓存**

连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。(缓存查询弊大于利，容易失效)

3. **分析器**

如果没有命中查询缓存，就要开始真正执行语句了，MySQL需要对语句进行分析。

分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。

做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

4. **优化器**

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

5. **执行器**

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

至此，这个语句就执行完成了。

## 存储引擎

存储引擎是 MySQL 中具体与文件打交道的子系统，它是根据 MySQL AB 公司提供的文件访问层抽象接口定制的一种文件访问机制，这种机制就叫作存储引擎，下面是一些常用的存储引擎，有远古时期的 MyISAM、支持事务的 InnoDB、内存类型的 Memory、归档类型的 Archive、列式存储的 Infobright，以及一些新兴的存储引擎。

 MyISAM索引文件和数据文件是分离的（非聚集）。

**区别：**

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  

3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 

4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    

5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

**如何选择：**

1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；

2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。

3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；

4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)

## 日志系统

提交事务的时候，会把redo log日志写入磁盘文件中去。然后其实在提交事务的时 候，我们同时还会把这次更新对应的binlog日志写入到磁盘文件中去，如下图所示。



存储 引擎的基本日志系统（包括redolog和undolog）如下：

![image-20201130164951811](https://gitee.com/adambang/pic/raw/master/20201130164951.png)

### redo log

在更新完Buffer Pool中的缓存页之后，必须要写一条redo log，这样才能记录下来我们对数据库做的修改。
redo log可以保证我们事务提交之后，如果事务中的增删改SQL语句更新的缓存页还没刷到磁盘上去，此时MySQL宕机了，那么MySQL重启过后，就可以把redo log重做一遍，恢复出来事务当时更新的缓存页，然后再把缓存页刷到磁盘就可以了
redo log本质是保证事务提交之后，修改的数据绝对不会丢失的  

**作用：**

确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

### undo log

**作用：**

保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

### binlog(Server层日志)

binlog叫做归档日志，里面记录的是偏向于逻辑性的日志，类似于“对users表中的id=10的一行数据做了更新操 作，更新以后的值是什么。

**作用**：<u>只记录修改语句，用于数据库恢复和主从复制，默认关闭</u>



### buffer pool

实际上假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。

缓冲池的构造如下，磁盘文件的数据页和buffer pool的缓存页一一对应。

![image-20201130170204206](https://gitee.com/adambang/pic/raw/master/20201130170204.png)

**缓存页如何和数据页对应：**

实际上默认情况下，磁盘中存放的数据页的大小是16KB，也就是说，一页数据包含了16KB的内容。
而Buffer Pool中存放的一个一个的数据页，我们通常叫做缓存页，因为毕竟Buffer Pool是一个缓冲池，里面的数据都是从磁盘缓存到内存去的。
而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。  

## 事务

### 事务特性

事务最基本的莫过于 ACID 四个特性了，这四个特性分别是：

**Atomicity：原子性**

事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败回滚。

**Consistency：一致性**

数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。

**Isolation：隔离性**

一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**Durability：持久性**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢。

事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwqHyYbEIPyeesNicgZ2s5NTGYL30g0TKLx51l4f5Hs9DUzWicjAgDLrJWse8Aia81kxtuJic5OXIrwBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom: 50%;" />

### 事务隔离级别

**未提交读（READ UNCOMMITTED）**

事务中的修改，即使没有提交，对其他事务也是可见的。

**提交读（READ COMMITTED）**

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。

**可重复读（REPEATABLE READ）**

保证在同一个事务中多次读取同样数据的结果是一样的。

**可串行化（SERIALIZABLE）**

强制事务串行执行。



事务问题

脏读（读未提交）：一个事务读取到另外一个事务还没有提交的数据

不可重复读（读提交）：在同一个事务内，两次相同的查询返回了不同的结果（修改）

幻读（可重复读）：同一个事务内多次查询返回的结果集不一样（新增/删除）

MySQL的RR隔离级别可通过MVCC避免幻读。MySQL实现MVCC机制的时候，是基于undo log多版本链条+ReadView机制的。

ReadView，里面比较关键的东西有4个

- m_ids，这个就是说此时有哪些事务在MySQL里执行还没提交的；
- min_trx_id，就是m_ids里最小的值；
- max_trx_id，这是说mysql下一个要生成的事务id，就是最大事务id；
- creator_trx_id，就是本事务的id  

## 锁

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

### 全局锁

顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份。**不加锁的情况：在可重复读隔离级别下开启一个事务，获取一致性视图。

风险

- 如果在主库备份，在备份期间不能更新，业务停摆
- 如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟

### 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

**表锁**

- 表锁的语法是 lock tables … read/write
- 可以用unlock tables主动释放锁，也可以在客户端断开时自动释放

**元数据锁（MDL)**

- MDL 不需要显式使用，在访问一个表的时候会被自动加上，保证读写的正确性
- 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
- 读读不互斥，读写/写写互斥

### 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时(提交)才释放。这个就是**两阶段锁协议**。

> 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为**死锁**。

当出现死锁以后，有两种策略：

- 一种策略是，直接进入**等待**，直到**超时**。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。

- 另一种策略是，发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

  超时时间设置过长影响业务，设置过短锁失去意义。

  死锁检测每个加锁的事务都要进行死锁判断，要耗费大量的 CPU 资源。

  解决方法：  

  1. 能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。（可能造成超时，业务有损）

  2. 控制并发度

## 索引

MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。

### 数据结构

二叉查找树

- 查找耗时与树的深度相关的，最坏时间复杂度会退化成O(n)

平衡二叉树

- 左右子树深度差绝对值不能超过 1
- 插入/删除节点，需要频繁调整树结构，性能较差
- 树的深度过深，磁盘IO开销较大

红黑树

- 叶子节点全黑，一红带两黑，弱平衡性
- 适用于删除插入操作较多的情况

B树

- 叶子节点，非叶子节点，都存储数据
- 中序遍历，可以获得所有节点

B+树

- 非叶子节点不再存储数据，数据只存储在同一层的叶子节点上
- 叶子之间，增加了链表，获取所有节点，不再需要中序遍历

### 索引分类

**结构**

- B树索引
- Hash索引
- 全文索引
- R-Tree 索引

类型

- 单值索引

- 唯一索引

- 复合索引

  - 覆盖索引

    查询的列刚好与创建的索引列的列名及顺序全部匹配或者部分匹配

### 索引创建场景

**哪些情况需要创建索引**

- 1.主键自动建立唯一索引

- 2.频繁作为查询的条件的字段应该创建索引

- 3.查询中与其他表关联的字段，外键关系建立索引

- 4.频繁更新的字段不适合创建索引

  因为每次更新不单单是更新了记录还会更新索引，加重IO负担

- 5.Where条件里用不到的字段不创建索引

- 6.单一索引/复合索引的选择问题，平时选择哪一个？who？（在高并发下倾向创建组合索引）

- 7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度

  比如你创建复合索引（name,age,address），那么排序的时候如果还按照name,age,address排序，速度会非常快。

- 8.查询中统计或者分组字段

**哪些情况不要创建索引**

- 1.表记录太少

  mysql虽然官方说能撑得住500到800万，但是实际上，300万条数据，性能就开始下降。

- 2.经常增删改的表

- 3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。 

  比如国籍，省市县，男女，这样的数据重复率高，这样的就不适合建索引。

  注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。





