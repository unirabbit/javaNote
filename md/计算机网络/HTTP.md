# HTTP基本概念

HTTP 是超文本传输协议，也就是 **H**yperText **T**ransfer **P**rotocol。

HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接， 这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服 务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向 服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。

## 传输流程

1. **地址解析** 如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、 端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 协议名：http 主机名：localhost.com 端口：8080 对象路径：/index.htm 13/04/2018 Page 165 of 283 在这一步，需要域名系统 *DNS 解析域名* localhost.com,得主机的 IP 地址。

> **DNS域名解析过程：**
>
> 1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。（TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。）
> 2. 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。 在 windows中可通过c盘里一个叫hosts的文件来设置， 如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改hosts文件里的内容把特定的域名解析到他指定的ip地址上， 造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。
> 3. 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
> 4. 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析
> 5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
> 6. 此时LDNS再发送请求给上一步返回的gTLD
> 7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
> 8. Name Server根据映射关系表找到目标ip，返回给LDNS
> 9. LDNS缓存这个域名和对应的ip
> 10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。

2. **封装 HTTP 请求数据包** 把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包
3. **封装成 TCP 包并建立连接** 封装成 TCP 包，建立 TCP 连接（TCP 的三次握手） 
4. **客户机发送请求命令** 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资 源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。 
5. **服务器响应** 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或 错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。 
6. **服务器关闭 TCP 连接** 一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连 接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送 后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求 建立新连接所需的时间，还节约了网络带宽。

## HTTP常见状态码

![img](https://gitee.com/adambang/pic/raw/master/640)

## HTTP常见字段

*Host*：客户端发送请求时，用来指定服务器的域名。

*Content-Length 字段*：服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。

*Connection 字段*： `Connection` 字段最常用于客户端要求服务器使用 TCP 持久连接(keep-alive)，以便其他请求复用。

*Content-Type 字段*:`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

*Content-Encoding 字段*:`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

## GET 与 POST

`Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。

而`POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

GET产生一个TCP数据包；POST产生两个TCP数据包。

> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
>
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
>
> 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
>
> 1. GET与POST都有自己的语义，不能随便混用。
>
> 2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
>
> 3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

# HTTP特点

## HTTP1.0

HTTP 协议老的标准是HTTP/1.0，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

因此产生如下两个问题：

1. **连接无法复用** 

连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

2. **head of line blocking**

head of line blocking会导致带宽无法被充分利用，以及后续健康请求会被不健康的请求阻塞，而且这种体验的损耗受网络环境影响，出现随机且难以监控。

## HTTP1.1

为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

改进点：

*1. 长连接*

HTTP1.1在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

*2. 管道网络传输*

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

*3.缓存处理 — 强缓存、协商缓存，启发式缓存（新增）*

HTTP1.1还加入了缓存处理（强缓存和协商缓存），新的字段如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）

**问题：**

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。

## HTTP2.0

- 多路复用 (Multiplexing)；
- 二进制分帧；
- 首部压缩；
- 服务端推送

## HTTPS

HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用 的端口号是 443。 过程大致如下：

**建立连接获取证书** 

1） SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握 手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算 法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所 需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书 的公司，公共秘钥）。 

**证书验证** 

2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公 共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。

 **数据加密和传输** 

3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务 器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。

![image-20201108141421580](https://gitee.com/adambang/pic/raw/master/image-20201108141421580.png)